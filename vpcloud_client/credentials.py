# coding: utf-8

"""
    Credential resolution and Auth0 token management for vpcloud_client.

    This module provides automatic credential resolution from multiple sources
    and handles Auth0 M2M token exchange and caching.

    Generated by OpenAPI Generator (https://openapi-generator.tech)
    Do not edit the class manually.
"""  # noqa: E501

import os
import time
import json
import logging
from pathlib import Path
from typing import Optional, Dict, Tuple
from configparser import ConfigParser, NoSectionError, NoOptionError

try:
    import httpx
except ImportError:
    httpx = None


logger = logging.getLogger("vpcloud_client.credentials")


class AuthenticationError(Exception):
    """Raised when authentication credentials cannot be resolved or are invalid."""
    pass


class CredentialProvider:
    """Resolves credentials from multiple sources in priority order.
    
    Credential resolution chain:
    1. Explicit values provided in code
    2. Environment variables
    3. Credentials file (~/.voltagepark/credentials)
    
    Environment variables:
    - VPCLOUD_ACCESS_TOKEN: Direct JWT token (highest priority)
    - VPCLOUD_CLIENT_ID: Auth0 M2M client ID
    - VPCLOUD_CLIENT_SECRET: Auth0 M2M client secret
    """
    
    CREDENTIALS_FILE = Path.home() / ".voltagepark" / "credentials"
    
    def __init__(
        self,
        access_token: Optional[str] = None,
        client_id: Optional[str] = None,
        client_secret: Optional[str] = None,
        profile: str = "default"
    ):
        """Initialize credential provider.
        
        :param access_token: Explicit JWT token (takes highest priority)
        :param client_id: Explicit Auth0 client ID
        :param client_secret: Explicit Auth0 client secret
        :param profile: Profile name to use from credentials file (default: "default")
        """
        self._explicit_access_token = access_token
        self._explicit_client_id = client_id
        self._explicit_client_secret = client_secret
        self._profile = profile
        self._credentials_cache: Optional[Dict[str, str]] = None
    
    def get_access_token(self) -> Optional[str]:
        """Get access token from explicit value, environment variable, or credentials file.
        
        :return: Access token if found, None otherwise
        """
        if self._explicit_access_token:
            return self._explicit_access_token
        
        # Check environment variable
        env_token = os.environ.get("VPCLOUD_ACCESS_TOKEN")
        if env_token:
            return env_token
        
        # Check credentials file
        file_creds = self.get_credentials_from_file()
        if file_creds and file_creds.get("access_token"):
            return file_creds["access_token"]
        
        return None
    
    def get_client_credentials(self) -> Tuple[Optional[str], Optional[str]]:
        """Get client_id and client_secret from resolution chain.
        
        :return: Tuple of (client_id, client_secret) or (None, None) if not found
        """
        # Check explicit values first
        client_id = self._explicit_client_id
        client_secret = self._explicit_client_secret
        
        # Check environment variables
        if not client_id:
            client_id = os.environ.get("VPCLOUD_CLIENT_ID")
        if not client_secret:
            client_secret = os.environ.get("VPCLOUD_CLIENT_SECRET")
        
        # Check credentials file
        if not client_id or not client_secret:
            creds = self._load_credentials_file()
            if creds:
                if not client_id:
                    client_id = creds.get("client_id")
                if not client_secret:
                    client_secret = creds.get("client_secret")
        
        return (client_id, client_secret)
    
    def get_credentials_from_file(self) -> Optional[Dict[str, str]]:
        """Get credentials from file, including access_token if present.
        
        :return: Dict with client_id, client_secret, and/or access_token, or None
        """
        creds = self._load_credentials_file()
        if creds:
            result = {}
            if creds.get("access_token"):
                result["access_token"] = creds["access_token"]
            if creds.get("client_id"):
                result["client_id"] = creds["client_id"]
            if creds.get("client_secret"):
                result["client_secret"] = creds["client_secret"]
            return result if result else None
        return None
    
    def _load_credentials_file(self) -> Optional[Dict[str, str]]:
        """Load credentials from ~/.voltagepark/credentials file.
        
        :return: Dict with credentials for the selected profile, or None
        """
        if self._credentials_cache is not None:
            return self._credentials_cache
        
        if not self.CREDENTIALS_FILE.exists():
            self._credentials_cache = {}
            return self._credentials_cache
        
        try:
            config = ConfigParser()
            config.read(self.CREDENTIALS_FILE)
            
            # Check if profile exists
            if not config.has_section(self._profile):
                logger.debug(f"Profile '{self._profile}' not found in credentials file")
                self._credentials_cache = {}
                return self._credentials_cache
            
            creds = {}
            try:
                if config.has_option(self._profile, "access_token"):
                    creds["access_token"] = config.get(self._profile, "access_token")
                if config.has_option(self._profile, "client_id"):
                    creds["client_id"] = config.get(self._profile, "client_id")
                if config.has_option(self._profile, "client_secret"):
                    creds["client_secret"] = config.get(self._profile, "client_secret")
            except (NoSectionError, NoOptionError):
                pass
            
            self._credentials_cache = creds
            return creds
        except Exception as e:
            logger.warning(f"Failed to read credentials file: {e}")
            self._credentials_cache = {}
            return self._credentials_cache


class Auth0TokenManager:
    """Manages Auth0 M2M token exchange and caching.
    
    Auth0 configuration:
    - Domain: voltagepark-harbor.us.auth0.com
    - Audience: Derived from API host URL (e.g., https://api.sea-1.voltagepark.com/harbor)
    """
    
    AUTH0_DOMAIN = "voltagepark-harbor.us.auth0.com"
    TOKEN_URL = f"https://{AUTH0_DOMAIN}/oauth/token"
    
    # Mapping from region/datacenter code to Auth0 audience
    # This map defines which audience to use when requesting tokens for each region
    REGION_AUDIENCE_MAP = {
        "sea1": "https://api.sea-1.voltagepark.com/harbor",
        "iad1": "https://api.iad-1.voltagepark.com/harbor",
    }
    
    @staticmethod
    def _extract_region_from_host(host: str) -> str:
        """Extract region/datacenter code from API host URL.
        
        :param host: API host URL (e.g., https://api.sea1.voltagepark.com)
        :return: Region code (e.g., "sea1") or None if not found
        """
        import re
        match = re.search(r'api\.([^.]+)\.voltagepark\.com', host)
        if match:
            return match.group(1)
        return None
    
    @staticmethod
    def _get_audience_for_region(region: str) -> str:
        """Get Auth0 audience for a given region.
        
        :param region: Region/datacenter code (e.g., "sea1", "iad1")
        :return: Auth0 audience URL for the region
        """
        if region in Auth0TokenManager.REGION_AUDIENCE_MAP:
            return Auth0TokenManager.REGION_AUDIENCE_MAP[region]
        # Fallback: try to construct audience from region
        # Some regions use hyphenated format (e.g., sea1 -> sea-1)
        if region.endswith('1') and len(region) == 4:
            base = region[:-1]
            return f"https://api.{base}-1.voltagepark.com/harbor"
        return f"https://api.{region}.voltagepark.com/harbor"
    
    @staticmethod
    def _get_audience_from_host(host: str) -> str:
        """Derive Auth0 audience from API host URL.
        
        :param host: API host URL (e.g., https://api.sea1.voltagepark.com)
        :return: Auth0 audience URL
        """
        region = Auth0TokenManager._extract_region_from_host(host)
        if region:
            return Auth0TokenManager._get_audience_for_region(region)
        # Fallback to default (sea1)
        return Auth0TokenManager.REGION_AUDIENCE_MAP.get("sea1", "https://api.sea-1.voltagepark.com/harbor")
    
    def __init__(self, client_id: str, client_secret: str, audience: Optional[str] = None, host: Optional[str] = None):
        """Initialize token manager.
        
        :param client_id: Auth0 M2M client ID
        :param client_secret: Auth0 M2M client secret
        :param audience: Auth0 audience URL (optional, will be derived from host if not provided)
        :param host: API host URL (used to derive audience if audience not provided)
        """
        self.client_id = client_id
        self.client_secret = client_secret
        if audience:
            self.audience = audience
        elif host:
            self.audience = self._get_audience_from_host(host)
        else:
            # Default to sea1 audience for backward compatibility
            self.audience = "https://api.sea-1.voltagepark.com/harbor"
        self._cached_token: Optional[str] = None
        self._token_expires_at: float = 0
    
    def get_token(self, force_refresh: bool = False) -> str:
        """Get a valid access token, refreshing if necessary.
        
        :param force_refresh: Force token refresh even if cached token is valid
        :return: Access token (JWT)
        :raises AuthenticationError: If token exchange fails
        """
        # Check if cached token is still valid (refresh 60 seconds before expiry)
        if not force_refresh and self._cached_token and time.time() < self._token_expires_at - 60:
            return self._cached_token
        
        # Exchange credentials for token
        if httpx is None:
            raise AuthenticationError(
                "httpx is required for Auth0 token exchange. "
                "Install it with: pip install httpx"
            )
        
        try:
            response = httpx.post(
                self.TOKEN_URL,
                json={
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                    "audience": self.audience,
                    "grant_type": "client_credentials"
                },
                headers={"Content-Type": "application/json"},
                timeout=10.0
            )
            response.raise_for_status()
            data = response.json()
            
            access_token = data.get("access_token")
            if not access_token:
                raise AuthenticationError("Auth0 response missing access_token")
            
            # Cache token with expiry
            expires_in = data.get("expires_in", 86400)  # Default 24 hours
            self._cached_token = access_token
            self._token_expires_at = time.time() + expires_in
            
            return access_token
            
        except httpx.HTTPStatusError as e:
            raise AuthenticationError(
                f"Auth0 token exchange failed with status {e.response.status_code}: {e.response.text}"
            ) from e
        except httpx.RequestError as e:
            raise AuthenticationError(f"Auth0 token exchange request failed: {e}") from e
        except Exception as e:
            raise AuthenticationError(f"Unexpected error during Auth0 token exchange: {e}") from e

