# coding: utf-8

"""
    Retry logic unit tests for vpcloud_client.

    Generated by OpenAPI Generator (https://openapi-generator.tech)
    Do not edit the class manually.
"""  # noqa: E501

import pytest
import time

from unittest.mock import Mock, patch, MagicMock
from vpcloud_client.retry import RetryStrategy
from vpcloud_client import Configuration, ApiClient
from vpcloud_client.exceptions import ApiException
from test.utils import MockResponse


class TestRetryStrategy:
    """RetryStrategy unit tests"""

    def test_retry_strategy_defaults(self):
        """Test RetryStrategy default values."""
        strategy = RetryStrategy()
        assert strategy.max_retries == 3
        assert strategy.backoff_factor == 2.0
        assert strategy.max_backoff == 60.0
        assert strategy.retry_on_status == [429, 500, 502, 503, 504]
        assert strategy.respect_retry_after_header == True
        assert strategy.jitter == True

    def test_retry_strategy_custom_values(self):
        """Test RetryStrategy with custom values."""
        strategy = RetryStrategy(
            max_retries=5,
            backoff_factor=1.5,
            max_backoff=30.0,
            retry_on_status=[429, 500],
            respect_retry_after_header=False,
            jitter=False
        )
        assert strategy.max_retries == 5
        assert strategy.backoff_factor == 1.5
        assert strategy.max_backoff == 30.0
        assert strategy.retry_on_status == [429, 500]
        assert strategy.respect_retry_after_header == False
        assert strategy.jitter == False

    def test_should_retry_status_codes(self):
        """Test status code retry decisions."""
        strategy = RetryStrategy()
        assert strategy.should_retry(429) == True
        assert strategy.should_retry(500) == True
        assert strategy.should_retry(502) == True
        assert strategy.should_retry(503) == True
        assert strategy.should_retry(504) == True
        assert strategy.should_retry(200) == False
        assert strategy.should_retry(400) == False
        assert strategy.should_retry(401) == False
        assert strategy.should_retry(403) == False
        assert strategy.should_retry(404) == False

    def test_should_retry_custom_status_codes(self):
        """Test should_retry with custom retry_on_status list."""
        strategy = RetryStrategy(retry_on_status=[429, 408])
        assert strategy.should_retry(429) == True
        assert strategy.should_retry(408) == True
        assert strategy.should_retry(500) == False

    def test_should_retry_exception_retryable(self):
        """Test should_retry_exception returns True for retryable exceptions."""
        strategy = RetryStrategy()
        assert strategy.should_retry_exception(TimeoutError()) == True
        assert strategy.should_retry_exception(ConnectionError()) == True

    def test_should_retry_exception_non_retryable(self):
        """Test should_retry_exception returns False for non-retryable exceptions."""
        strategy = RetryStrategy()
        assert strategy.should_retry_exception(ValueError()) == False
        assert strategy.should_retry_exception(KeyError()) == False

    def test_exponential_backoff(self):
        """Test exponential backoff calculation."""
        strategy = RetryStrategy(backoff_factor=2.0, jitter=False)
        assert strategy.get_backoff_delay(1) == 1.0
        assert strategy.get_backoff_delay(2) == 2.0
        assert strategy.get_backoff_delay(3) == 4.0
        assert strategy.get_backoff_delay(4) == 8.0

    def test_backoff_max_cap(self):
        """Test backoff delay is capped at max_backoff."""
        strategy = RetryStrategy(backoff_factor=2.0, max_backoff=5.0, jitter=False)
        assert strategy.get_backoff_delay(4) == 5.0  # 2^3 = 8, but capped at 5.0

    def test_backoff_with_jitter(self):
        """Test backoff delay includes jitter."""
        strategy = RetryStrategy(backoff_factor=2.0, jitter=True)
        delay = strategy.get_backoff_delay(2)
        # Should be between 2.0 and 2.5 (2.0 + 25% jitter)
        assert 2.0 <= delay <= 2.5

    def test_backoff_retry_after_header(self):
        """Test backoff delay respects Retry-After header."""
        strategy = RetryStrategy(backoff_factor=2.0, jitter=False)
        delay = strategy.get_backoff_delay(2, retry_after=10.0)
        assert delay == 10.0

    def test_backoff_retry_after_ignored(self):
        """Test Retry-After header is ignored when respect_retry_after_header=False."""
        strategy = RetryStrategy(
            backoff_factor=2.0,
            respect_retry_after_header=False,
            jitter=False
        )
        delay = strategy.get_backoff_delay(2, retry_after=10.0)
        assert delay == 2.0  # Should use exponential backoff

    def test_parse_retry_after_integer_seconds(self):
        """Test parsing Retry-After as integer seconds."""
        strategy = RetryStrategy()
        assert strategy.parse_retry_after_header("5") == 5.0
        assert strategy.parse_retry_after_header("10") == 10.0

    def test_parse_retry_after_http_date(self):
        """Test parsing Retry-After as HTTP-date."""
        strategy = RetryStrategy()
        from datetime import datetime, timedelta
        import time
        future_time = datetime.now() + timedelta(seconds=30)
        # Use proper HTTP-date format
        http_date = future_time.strftime("%a, %d %b %Y %H:%M:%S GMT")
        parsed = strategy.parse_retry_after_header(http_date)
        # The parsing might fail if email.utils is not available or format is wrong
        # So we check if it's either None (failed) or a valid delay
        if parsed is not None:
            assert 25.0 <= parsed <= 35.0  # Allow some tolerance
        else:
            # If parsing failed, that's acceptable - the method handles it gracefully
            pass

    def test_parse_retry_after_invalid(self):
        """Test parsing invalid Retry-After values."""
        strategy = RetryStrategy()
        assert strategy.parse_retry_after_header(None) is None
        assert strategy.parse_retry_after_header("invalid") is None
        assert strategy.parse_retry_after_header("") is None


class TestRetryIntegration:
    """Retry logic integration tests"""

    @pytest.fixture
    def retry_config(self):
        """Configuration with retry enabled."""
        return Configuration(
            host="https://api.test.example.com",
            retry_strategy=RetryStrategy(max_retries=2, jitter=False)
        )

    
    def test_retry_on_429(self, retry_config):
        """Test retry logic handles 429 responses."""
        api_client = ApiClient(retry_config)
        
        # Mock responses: 429, then 200
        mock_responses = [
            MockResponse(429, headers={"Retry-After": "1"}),
            MockResponse(200, data=b'{"success": true}')
        ]
        
        with patch.object(api_client.rest_client, 'request', side_effect=mock_responses):
            response = api_client.call_api("GET", "https://api.test.example.com/test")
            assert response.status == 200

    
    def test_retry_exhausted(self, retry_config):
        """Test exception raised when retries exhausted."""
        api_client = ApiClient(retry_config)
        
        # Mock responses: always return 500
        mock_response = MockResponse(500, data=b'{"error": "server error"}')
        
        with patch.object(api_client.rest_client, 'request', return_value=mock_response):
            with pytest.raises(ApiException) as exc_info:
                api_client.call_api("GET", "https://api.test.example.com/test")
            assert exc_info.value.status == 500

    
    def test_no_retry_on_400(self, retry_config):
        """Test that 400 Bad Request does not trigger retry."""
        api_client = ApiClient(retry_config)
        
        mock_response = MockResponse(400, data=b'{"error": "bad request"}')
        
        with patch.object(api_client.rest_client, 'request', return_value=mock_response) as mock_request:
            # call_api returns the response directly (exceptions are raised in response_deserialize)
            response = api_client.call_api(
                "GET", 
                "https://api.test.example.com/test",
                header_params={}
            )
            # Verify 400 status is returned
            assert response.status == 400
            # Should only be called once (no retries for 400)
            assert mock_request.call_count == 1

